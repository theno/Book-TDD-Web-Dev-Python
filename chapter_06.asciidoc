[[chapter-6]]
Getting to the Minimum Viable Site
----------------------------------

... In which we use incremental, step-by-step refactoring to get to a better
app.  Testing Goat, not Refactoring Cat!


Ensuring Test Isolation in Functional Tests
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We ended the last chapter with a classic testing problem:  how to ensure
'isolation' between tests.  

[subs="specialcharacters,quotes"]
----
$ *mkdir functional_tests*
$ *touch functional_tests/__init__.py*
----

Then move the FT file:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*git mv functional_tests.py functional_tests/tests.py*]
$ pass:quotes[*git status*] # shows the rename to functional_tests/tests.py and __init__.py
----

At this point your directory tree should look like this:

----
.
├── db.sqlite3
├── functional_tests
│   ├── __init__.py
│   └── tests.py
├── lists
│   ├── admin.py
│   ├── __init__.py
│   ├── migrations
│   │   ├── 0001_initial.py
│   │   ├── 0002_item_text.py
│   │   ├── __init__.py
│   │   └── __pycache__
│   ├── models.py
│   ├── __pycache__
│   ├── templates
│   │   └── home.html
│   ├── tests.py
│   └── views.py
├── manage.py
└── superlists
    ├── __init__.py
    ├── __pycache__
    ├── settings.py
    ├── urls.py
    └── wsgi.py
----

'functional_tests.py' is gone, and has turned into 'functional_tests/tests.py'.
Now, whenever we want to run our functional tests, instead of running `python3
functional_tests.py`, we will use `python3 manage.py test functional_tests`.


NOTE: discuss why keep FTs separate from other apps?


Now let's edit 'functional_tests/tests.py' and change our `NewVisitorTest`
class to make it use `LiveServerTestCase`:

[role="sourcecode"]
.functional_tests/tests.py (ch06l001)
[source,python]
----
from django.test import LiveServerTestCase
from selenium import webdriver
from selenium.webdriver.common.keys import Keys

class NewVisitorTest(LiveServerTestCase):

    def setUp(self):
        [...]
----

Next,
instead of hard-coding the visit to localhost port 8000, `LiveServerTestCase`
gives us an attribute called `live_server_url`:


[role="dofirst-ch06l003 sourcecode"]
.functional_tests/tests.py (ch06l002)
[source,python]
----
    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get(self.live_server_url)
----

Now we are able to run our Functional tests using the Django test runner, by
telling it to run just the tests for our new `functional_tests` app:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later
(functional_tests.tests.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/functional_tests/tests.py", line 61, in
test_can_start_a_list_and_retrieve_it_later
    self.fail('Finish the test!')
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 1 test in 6.378s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

Woot!

.Avanced Exercise: hand-rolled database cleanup
*******************************************************************************
Before LiveServerTestCase, you had to do this stuff yourself!  And it still
has some benefits.

You can check out one of my old attempts, for inspiration, if you like:
https://github.com/hjwp/Test-Driven-Django-Tutorial/blob/old-ft-runner/mysite/functional_tests.py[old-ft-runner]
*******************************************************************************


[subs="specialcharacters,quotes"]
----
$ *git status* # functional_tests.py renamed + modified, new __init__.py
$ *git add functional_tests*
$ *git diff --staged -M*
$ *git commit*  # msg eg "make functional_tests an app, use LiveServerTestCase"
----

The `-M` flag on the `git diff` is a useful one. It means "detect moves", so it
will notice that 'functional_tests.py' and 'functional_tests/tests.py' are the
same file, and show you a more sensible diff (try it without the flag!).


Running Just the Unit Tests
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now if we run `manage.py test`, Django will run both the functional and the
unit tests:


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test*]
Creating test database for alias 'default'...
.......F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later
[...]
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 8 tests in 3.132s

FAILED (failures=1)
Destroying test database for alias 'default'...
----

In order to run just the unit tests, we can specify that we want to
only run the tests for the `lists` app:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
Creating test database for alias 'default'...
.......
 ---------------------------------------------------------------------
Ran 7 tests in 0.009s

OK
Destroying test database for alias 'default'...
----



.Useful Commands Updated
*******************************************************************************

To run the functional tests::
    *`python3 manage.py test functional_tests`*

To run the unit tests::
    *`python3 manage.py test lists`*

*******************************************************************************

Currently the FT says this:

[role="sourcecode"]
.functional_tests/tests.py
[source,python]
----
    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generate a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')

    # She visits that URL - her to-do list is still there.

    # Satisfied, she goes back to sleep
----

Let's think about this a bit more.


Small Design When Necessary
~~~~~~~~~~~~~~~~~~~~~~~~~~~

* Big Design up-front
* Minimum viable app
* YAGNI
* REST (ish)


Each list can have its own URL, like


[role="skipme"]
----
    /lists/<list identifier>/
----

To create a brand new list, we'll have a special URL that accepts POST
requests:

[role="skipme"]
----
    /lists/new
----

To add a new item to an existing list, we'll have a separate URL, to which
we can send POST requests:

[role="skipme"]
----
    /lists/<list identifier>/add_item
----

In summary, our scratchpad for this chapter looks something like this:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* 'Adjust model so that items are associated with different lists'
* 'Add unique URLs for each list'
* 'Add a URL for creating a new list via POST'
* 'Add URLs for adding a new item to an existing list via POST'
*****


Implementing the New Design Using TDD
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[role="sourcecode"]
.functional_tests/tests.py
[source,python]
----
    inputbox.send_keys('Buy peacock feathers')

    # When she hits enter, she is taken to a new URL,
    # and now the page lists "1: Buy peacock feathers" as an item in a
    # to-do list table
    inputbox.send_keys(Keys.ENTER)
    edith_list_url = self.browser.current_url
    self.assertRegex(edith_list_url, '/lists/.+') #<1>
    self.check_for_row_in_list_table('1: Buy peacock feathers')

    # There is still a text box inviting her to add another item. She
    [...]
----

Delete everything from the comments just before the `self.fail` (they say
"Edith wonders whether the site will remember her list ...") and replace
them with a new ending to our FT:

[role="sourcecode"]
.functional_tests/tests.py
[source,python]
----
    [...]
    # The page updates again, and now shows both items on her list
    self.check_for_row_in_list_table('2: Use peacock feathers to make a fly')
    self.check_for_row_in_list_table('1: Buy peacock feathers')

    # Now a new user, Francis, comes along to the site.

    ## We use a new browser session to make sure that no information
    ## of Edith's is coming through from cookies etc #<1>
    self.browser.quit()
    self.browser = webdriver.Firefox()

    # Francis visits the home page.  There is no sign of Edith's
    # list
    self.browser.get(self.live_server_url)
    page_text = self.browser.find_element_by_tag_name('body').text
    self.assertNotIn('Buy peacock feathers', page_text)
    self.assertNotIn('make a fly', page_text)

    # Francis starts a new list by entering a new item. He
    # is less interesting than Edith...
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Buy milk')
    inputbox.send_keys(Keys.ENTER)

    # Francis gets his own unique URL
    francis_list_url = self.browser.current_url
    self.assertRegex(francis_list_url, '/lists/.+')
    self.assertNotEqual(francis_list_url, edith_list_url)

    # Again, there is no trace of Edith's list
    page_text = self.browser.find_element_by_tag_name('body').text
    self.assertNotIn('Buy peacock feathers', page_text)
    self.assertIn('Buy milk', page_text)

    # Satisfied, they both go back to sleep
----


*Ask about: double-hashes (`##`)

Gives


----
AssertionError: Regex didn't match: '/lists/.+' not found in
'http://localhost:8081/'
----


[subs="specialcharacters,quotes"]
----
$ *git commit -a*
----


Iterating Towards the New Design
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The URL comes from the redirect after POST.  In 'lists/tests.py', find
`test_home_page_redirects_after_POST`, and change the expected redirect
location:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
self.assertEqual(response.status_code, 302)
self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----

NOTE: Another way of thinking about it is as a problem-solving technique: our
    new URL design is currently not implemented, so it works for 0 items.
    Ultimately, we want to solve for 'n' items, but solving for 1 item is a
    good step along the way.

Running the unit tests gives us an expected fail:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
AssertionError: '/' != '/lists/the-only-list-in-the-world/'
----

We can go adjust our `home_page` view in 'lists/views.py':

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/lists/the-only-list-in-the-world/')

    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----

Of course that will now totally break the functional test.


----
    self.check_for_row_in_list_table('1: Buy peacock feathers')
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"id","selector":"id_list_table"}
----


//IDEA: improve FT for better error messages when table missing

So, let's build a special URL for our one and only list.


Testing Views, Templates, and URLs Together with the Django Test Client
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


A New Test Class
^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/tests.py (ch06l009)
[source,python]
----
class ListViewTest(TestCase):

    def test_displays_all_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        response = self.client.get('/lists/the-only-list-in-the-world/') #<1>

        self.assertContains(response, 'itemey 1') #<2>
        self.assertContains(response, 'itemey 2') #<2>

----

Let's try running the test now:

----
AssertionError: 404 != 200 : Couldn't retrieve content: Response code was 404
----


A New URL
^^^^^^^^^

Our singleton list URL doesn't exist yet.  We fix that in 'superlists/urls.py'.

TIP: Watch out for trailing slashes in URLs, both here in the tests and in
%%urls.py%%&mdash;They're a common source of bugs.

[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/the-only-list-in-the-world/$', 'lists.views.view_list',
        name='view_list'
    ),
    # url(r'^admin/', include(admin.site.urls)),
)
----

Running the tests again, we get:

----
AttributeError: 'module' object has no attribute 'view_list'
[...]
django.core.exceptions.ViewDoesNotExist: Could not import
lists.views.view_list. View does not exist in module lists.views.
----

A New View Function
^^^^^^^^^^^^^^^^^^^

Nicely self-explanatory.  Let's create a dummy view function in 'lists/views.py':

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request):
    pass
----

Now we get:

----
ValueError: The view lists.views.view_list didn't return an HttpResponse
object. It returned None instead.
----

Let's copy the two last lines from the `home_page` view and see if they'll do
the trick:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request):
    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----

Rerun the tests and they should pass:

----
Ran 8 tests in 0.016s
OK
----

And the FTs should get a little further on:

----
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers']
----

Green? Refactor
+++++++++++++++

Time for a little tidying up.  

[subs="specialcharacters,quotes"]
----
$ *grep -E "class|def" lists/tests.py*
class HomePageTest(TestCase):
    def test_root_url_resolves_to_home_page_view(self):
    def test_home_page_returns_correct_html(self):
    def test_home_page_displays_all_list_items(self):
    def test_home_page_can_save_a_POST_request(self):
    def test_home_page_redirects_after_POST(self):
    def test_home_page_only_saves_items_when_necessary(self):
class ListViewTest(TestCase):
    def test_displays_all_items(self):
class ItemModelTest(TestCase):
    def test_saving_and_retrieving_items(self):
----


We can definitely delete the `test_home_page_displays_all_list_items` method,
it's no longer needed.  If you run *`manage.py test lists`* now, it should say
it ran 7 tests instead of 8:


[role="dofirst-ch06l010"]
----
Ran 7 tests in 0.016s
OK
----

Next, we don't actually need the home page to display all list items any more;
it should just show a single input box inviting you to start a new list.


A Separate Template for Viewing Lists
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

[role="sourcecode"]
.lists/tests.py
[source,python]
----
class ListViewTest(TestCase):

    def test_uses_list_template(self):
        response = self.client.get('/lists/the-only-list-in-the-world/')
        self.assertTemplateUsed(response, 'list.html')


    def test_displays_all_items(self):
        [...]

----

Let's see what it says:


----
AssertionError: False is not true : Template 'list.html' was not a template
used to render the response. Actual template(s) used: home.html
----


Great!  Let's change the view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request):
    items = Item.objects.all()
    return render(request, 'list.html', {'items': items})
----

But, obviously, that template doesn't exist yet. If we run the unit tests, we
get:

----
django.template.base.TemplateDoesNotExist: list.html
----

Let's create a new file at 'lists/templates/list.html':

[subs="specialcharacters,quotes"]
----
$ *touch lists/templates/list.html*
----

A blank template, which gives us this error--good to know the tests are
there to make sure we fill it in:

----
AssertionError: False is not true : Couldn't find 'itemey 1' in response
----

[subs="specialcharacters,quotes"]
----
$ *cp lists/templates/home.html lists/templates/list.html*
----

[role="sourcecode small-code"]
.lists/templates/home.html
[source,html]
----
<body>
    <h1>Start a new To-Do list</h1>
    <form method="POST">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
        {% csrf_token %}
    </form>
</body>
----

[role="sourcecode"]
.lists/templates/list.html
[source,html]
----
    <h1>Your To-Do list</h1>
----

We re-run the unit tests to check that hasn't broken anything... Good...


There's actually no need to pass all the items to the 'home.html' template in
our `home_page` view, so we can simplify that:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/lists/the-only-list-in-the-world/')
    return render(request, 'home.html')
----


Rerun the unit tests; they still pass. Let's run the functional tests:

----
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers']
----


The `action=` attribute...


[role="sourcecode"]
.lists/templates/list.html (ch06l019)
[source,html]
----
    <form method="POST" action="/">
----

And try running the FT again:

----
    self.assertNotEqual(francis_list_url, edith_list_url)
AssertionError: 'http://localhost:8081/lists/the-only-list-in-the-world/' ==
'http://localhost:8081/lists/the-only-list-in-the-world/'
----

Hooray! We're back to where we were earlier, which means our refactoring is
complete--we now have a unique URL for our one list.

[subs="specialcharacters,quotes"]
----
$ *git status* # should show 4 changed files and 1 new file, list.html
$ *git add lists/templates/list.html*
$ *git diff* # should show we've simplified home.html,
           # moved one test to a new class in lists/tests.py added a new view
           # in views.py, and simplified home_page and made one addition to
           # urls.py
$ *git commit -a* # add a message summarising the above, maybe something like
                # "new URL, view and template to display lists"
----


Another URL and View for Adding List Items
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Where are we with our own to-do list?

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* 'Adjust model so that items are associated with different lists'
* 'Add unique URLs for each list'
* 'Add a URL for creating a new list via POST'
* 'Add URLs for adding a new item to an existing list via POST'
*****

Let's have a new URL for adding new list items.  If nothing else, it'll
simplify the home page view.


A Test Class for New List Creation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Open up 'lists/tests.py', and 'move' the
`test_home_page_can_save_a_POST_request` and
`test_home_page_redirects_after_POST` methods into a new class, then change
their names:


NOTE: if you didn't do the advanced exercise in the last section, you'll only
have one method here. That's fine.


[role="sourcecode"]
.lists/tests.py (ch06l021-1)
[source,python]
----
class NewListTest(TestCase):

    def test_saving_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        [...]

    def test_redirects_after_POST(self):
        [...]
----


((("Django", "test client")))
Now let's use the Django test client:


[role="sourcecode small-code"]
.lists/tests.py (ch06l021-2)
[source,python]
----
class NewListTest(TestCase):

    def test_saving_a_POST_request(self):
        self.client.post(
            '/lists/new',
            data={'item_text': 'A new list item'}
        )
        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, 'A new list item')


    def test_redirects_after_POST(self):
        response = self.client.post(
            '/lists/new',
            data={'item_text': 'A new list item'}
        )

        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/lists/the-only-list-in-the-world/')
----

This is another place to pay attention to trailing slashes, incidentally. It's
`/new`, with no trailing slash.  The convention I'm using is that URLs without
a trailing slash are "action" URLs which modify the database.

Try running that:

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
[...]
    self.assertEqual(response.status_code, 302)
AssertionError: 404 != 302
----


A URL and View for New List Creation
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Let's build our new URL now:


//22
[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/the-only-list-in-the-world/$', 'lists.views.view_list',
        name='view_list'
    ),
    url(r'^lists/new$', 'lists.views.new_list', name='new_list'),
    # url(r'^admin/', include(admin.site.urls)),
)
----

Next we get a `ViewDoesNotExist`, so let's fix that, in 'lists/views.py':

[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    pass
----


[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    return redirect('/lists/the-only-list-in-the-world/')
----

That gives:

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
[...]
AssertionError: 'http://testserver/lists/the-only-list-in-the-world/' !=
'/lists/the-only-list-in-the-world/'
----

Let's start with the first failure, because it's reasonably straightforward. We
borrow another line from `home_page`:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def new_list(request):
    Item.objects.create(text=request.POST['item_text'])
    return redirect('/lists/the-only-list-in-the-world/')
----

And that takes us down to just the second, unexpected failure:

----
    self.assertEqual(response['location'],
'/lists/the-only-list-in-the-world/')
AssertionError: 'http://testserver/lists/the-only-list-in-the-world/' !=
'/lists/the-only-list-in-the-world/'
----

Let's use another of Django's test helper functions instead of our two-step
check for the redirect:


//22?
[role="sourcecode"]
.lists/tests.py
[source,python]
----
    def test_redirects_after_POST(self):
        response = self.client.post(
            '/lists/new',
            data={'item_text': 'A new list item'}
        )
        self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
----

That now passes:

----
Ran 8 tests in 0.030s

OK
----


Removing Now-Redundant Code and Tests
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("functional tests/testing (FT)","cleanup")))
We're looking good. Since our new views are now doing most of the work that
`home_page` used to do, we should be able to massively simplify it. Can we
remove the whole `if request.method == 'POST'` section, for example?

++++
<?hard-pagebreak?>
++++

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    return render(request, 'home.html')
----

Yep!

----
OK
----

And while we're at it, we can remove the now-redundant
`test_home_page_only_saves_` `items_when_necessary` test too!

Doesn't that feel good?  The view functions are looking much simpler. We rerun
the tests to make sure...

[role="dofirst-ch06l026"]
----
Ran 7 tests in 0.016s
OK
----


Pointing Our Forms at the New URL
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("URLs", "pointing forms to")))
((("Django", "URLs in")))
((("URLs", "in Django")))
Finally, let's wire up our two forms to use this new URL.  In 'both'
'home.html' and 'lists.html':

//ch06l027
[role="sourcecode"]
.lists/templates/home.html, lists/templates/list.html
[source,html]
----
    <form method="POST" action="/lists/new">
----

.Advanced Exercise
*******************************************************************************

We're violating DRY with all these hard-coded URLs.  Investigate the Django
`{% url %}` tag, and the `reverse` and `redirect` functions, and use them as
appropriate

*******************************************************************************

And we re-run our FTs to make sure everything still works...


----
AssertionError: 'http://localhost:8081/lists/the-only-list-in-the-world/' ==
'http://localhost:8081/lists/the-only-list-in-the-world/'
----

[subs="specialcharacters,quotes"]
----
$ *git status* # 5 changed files
$ *git diff* # URLs for forms x2, moved code in views + tests, new URL
$ *git commit -a*
----

And we can cross out an item on the to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* 'Adjust model so that items are associated with different lists'
* 'Add unique URLs for each list'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* 'Add URLs for adding a new item to an existing list via POST'
*****

Adjusting Our Models
~~~~~~~~~~~~~~~~~~~~

Just for fun, a diff output instead of a plain code listing:

//(ch06l028)
[role="sourcecode"]
.lists/tests.py
[source,diff]
----
@@ -3,7 +3,7 @@ from django.http import HttpRequest
 from django.template.loader import render_to_string
 from django.test import TestCase
 
-from lists.models import Item
+from lists.models import Item, List
 from lists.views import home_page
 
 class HomePageTest(TestCase):
@@ -60,22 +60,32 @@ class ListViewTest(TestCase):
 
 
 
-class ItemModelTest(TestCase):
+class ListAndItemModelsTest(TestCase):
 
     def test_saving_and_retrieving_items(self):
+        list_ = List()
+        list_.save()
+
         first_item = Item()
         first_item.text = 'The first (ever) list item'
+        first_item.list = list_
         first_item.save()
 
         second_item = Item()
         second_item.text = 'Item the second'
+        second_item.list = list_
         second_item.save()
 
+        saved_list = List.objects.first()
+        self.assertEqual(saved_list, list_)
+
         saved_items = Item.objects.all()
         self.assertEqual(saved_items.count(), 2)
 
         first_saved_item = saved_items[0]
         second_saved_item = saved_items[1]
         self.assertEqual(first_saved_item.text, 'The first (ever) list item')
+        self.assertEqual(first_saved_item.list, list_)
         self.assertEqual(second_saved_item.text, 'Item the second')
+        self.assertEqual(second_saved_item.list, list_)
----

NOTE: I'm using the variable name `list_` to avoid "shadowing" the Python
built-in `list` function.  It's ugly, but all the other options I tried were
equally ugly or worse (`my_list`, `the_list`, `list1`, `listey`...).

Time for another unit-test/code cycle.   

For the first couple of iterations, rather than explicitly showing you what
code to enter in between every test run, I'm only going to show you the
expected error messages from running the tests.  I'll let you figure out what
each minimal code change should be on your own:

Your first error should be:

[subs="specialcharacters,macros"]
----
ImportError: cannot import name 'List'
----

Fix that, then you should see:

[role="dofirst-ch06l029-1"]
----
AttributeError: 'List' object has no attribute 'save'
----

Next you should see:

[role="dofirst-ch06l029-2"]
----
django.db.utils.OperationalError: no such table: lists_list
----

So we run a `makemigrations`:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py makemigrations*]
Migrations for 'lists':
  0003_list.py:
    - Create model List
----

And then you should see:

----
    self.assertEqual(first_saved_item.list, list_)
AttributeError: 'Item' object has no attribute 'list'
----


A Foreign Key Relationship
^^^^^^^^^^^^^^^^^^^^^^^^^^

How do we give our `Item` a list attribute?  Let's just try naively making it
like the `text` attribute:

[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.db import models

class List(models.Model):
    pass

class Item(models.Model):
    text = models.TextField(default='')
    list = models.TextField(default='')
----
//029-4

As usual, the tests tell us we need a migration:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
django.db.utils.OperationalError: no such column: lists_item.list

$ pass:quotes[*python3 manage.py makemigrations*]
Migrations for 'lists':
  0004_item_list.py:
    - Add field list to item
----


Let's see what that gives us:

----
AssertionError: 'List object' != <List: List object>
----


We're not quite there. Look closely at each side of the `!=`.  Django has only
saved the string representation of the `List` object. To save the relationship
to the object itself, we tell Django about the relationship between the two
classes using a `ForeignKey`:

[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.db import models

class List(models.Model):
    pass


class Item(models.Model):
    text = models.TextField(default='')
    list = models.ForeignKey(List, default=None)
----
//029-5


((("migrations", "deleting")))
That'll need a migration too.  Since the last one was a red herring, let's
delete it and replace it with a new one:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*rm lists/migrations/0004_item_list.py*]
$ pass:quotes[*python3 manage.py makemigrations*]
Migrations for 'lists':
  0004_item_list.py:
    - Add field list to item
----

NOTE: ask about why deleting migrations is dangerous


.Advanced Exercise
*******************************************************************************
If you switch to a `CharField` instead of a `TextField`, you'll see we need
a `max_length` attribute.  How would you test that?  It's not obvious,
so ask for a hint if you need one...
*******************************************************************************


Adjusting the Rest of the World to Our New Models
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


Back in our tests, now what happens?


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
ERROR: test_displays_all_items (lists.tests.ListViewTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id
[...]
ERROR: test_redirects_after_POST (lists.tests.NewListTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id
[...]
ERROR: test_saving_a_POST_request (lists.tests.NewListTest)
django.db.utils.IntegrityError: NOT NULL constraint failed: lists_item.list_id

Ran 7 tests in 0.021s

FAILED (errors=3)
----

Oh gawd!  Still, this is exactly why we have tests.


[role="sourcecode"]
.lists/tests.py (ch06l031)
[source,python]
----
class ListViewTest(TestCase):

    def test_displays_all_items(self):
        list_ = List.objects.create()
        Item.objects.create(text='itemey 1', list=list_)
        Item.objects.create(text='itemey 2', list=list_)
----


That gets us down to two failing tests, both on tests that try to POST to our
`new_list` view. Decoding the tracebacks using our usual technique, working back
from error, to line of test code, to the line of our own code that caused the
failure, we identify:

[subs="specialcharacters,macros"]
----
File "/workspace/superlists/lists/views.py", line 14, in new_list
Item.objects.create(text=request.POST['item_text'])
----
//shld line 14 be line 9?

It's when we try and create an item without a parent list. So we make a similar
change in the view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
from lists.models import Item, List
[...]
def new_list(request):
    list_ = List.objects.create()
    Item.objects.create(text=request.POST['item_text'], list=list_)
    return redirect('/lists/the-only-list-in-the-world/')
----

And that gets our tests passing again:

----
OK
----

NOTE: Are you cringing internally at this point?  Ask!

Anyway, just to reassure ourselves that things have worked, we can re-run the
FT.  


[subs="specialcharacters,quotes"]
----
$ *git status* # 3 changed files, plus 2 migrations
$ *git add lists*
$ *git diff --staged*
$ *git commit*
----

And we can cross out another item on the to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* '[strikethrough line-through]#Adjust model so that items are associated with different lists#'
* 'Add unique URLs for each list'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* 'Add URLs for adding a new item to an existing list via POST'
*****

Each List Should Have Its Own URL
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[role="sourcecode"]
.lists/tests.py (ch06l033-1)
[source,python]
----
class ListViewTest(TestCase):

    def test_uses_list_template(self):
        list_ = List.objects.create()
        response = self.client.get('/lists/%d/' % (list_.id,))
        self.assertTemplateUsed(response, 'list.html')


    def test_displays_only_items_for_that_list(self):
        correct_list = List.objects.create()
        Item.objects.create(text='itemey 1', list=correct_list)
        Item.objects.create(text='itemey 2', list=correct_list)
        other_list = List.objects.create()
        Item.objects.create(text='other list item 1', list=other_list)
        Item.objects.create(text='other list item 2', list=other_list)

        response = self.client.get('/lists/%d/' % (correct_list.id,))

        self.assertContains(response, 'itemey 1')
        self.assertContains(response, 'itemey 2')
        self.assertNotContains(response, 'other list item 1')
        self.assertNotContains(response, 'other list item 2')
----

Running the unit tests gives an expected 404, and another related error:

----
FAIL: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
AssertionError: 404 != 200 : Couldn't retrieve content: Response code was 404
(expected 200)
[...]
FAIL: test_uses_list_template (lists.tests.ListViewTest)
AssertionError: No templates used to render the response
----


Capturing Parameters from URLs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

((("URLs", "capturing parameters in")))
It's time to learn how we can pass parameters from URLs to views:


[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/(.+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^lists/new$', 'lists.views.new_list', name='new_list'),
    # url(r'^admin/', include(admin.site.urls)),
)
----

But our view doesn't expect an argument yet! Sure enough, this causes problems:

----
ERROR: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
ERROR: test_uses_list_template (lists.tests.ListViewTest)
ERROR: test_redirects_after_POST (lists.tests.NewListTest)
[...]
TypeError: view_list() takes 1 positional argument but 2 were given
----

We can fix that easily with a dummy parameter in 'views.py':

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    [...]
----

Now we're down to our expected failure:

----
FAIL: test_displays_only_items_for_that_list (lists.tests.ListViewTest)
AssertionError: 1 != 0 : Response should not contain 'other list item 1'
----

Let's make our view discriminate over which items it sends to the
template:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    items = Item.objects.filter(list=list_)
    return render(request, 'list.html', {'items': items})
----


Adjusting new_list to the New World
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now we get errors in another test:

----
ERROR: test_redirects_after_POST (lists.tests.NewListTest)
ValueError: invalid literal for int() with base 10:
'the-only-list-in-the-world'
----

Let's take a look at this test then, since it's whining:


[role="sourcecode currentcontents"]
.lists/tests.py
[source,python]
----
class NewListTest(TestCase):
    [...]

    def test_redirects_after_POST(self):
        response = self.client.post(
            '/lists/new',
            data={'item_text': 'A new list item'}
        )
        self.assertRedirects(response, '/lists/the-only-list-in-the-world/')
----

It looks like it hasn't been adjusted to the new world of Lists and Items.
The test should be saying that this view redirects to the URL of the new list
it just created:

[role="sourcecode"]
.lists/tests.py (ch06l036-1)
[source,python]
----
    def test_redirects_after_POST(self):
        response = self.client.post(
            '/lists/new',
            data={'item_text': 'A new list item'}
        )
        new_list = List.objects.first()
        self.assertRedirects(response, '/lists/%d/' % (new_list.id,))
----


That still gives us the 'invalid literal' error. We take a look at the view
itself, and change it so it redirects to a valid place:

[role="sourcecode"]
.lists/views.py (ch06l036-2)
[source,python]
----
def new_list(request):
    list_ = List.objects.create()
    Item.objects.create(text=request.POST['item_text'], list=list_)
    return redirect('/lists/%d/' % (list_.id,))
----

That gets us back to passing unit tests.  What about the functional
tests?  We must be almost there?

----
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Use
peacock feathers to make a fly']
----

And it correlates nicely with the last item on our to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* '[strikethrough line-through]#Adjust model so that items are associated with different lists#'
* '[strikethrough line-through]#Add unique URLs for each list#'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* 'Add URLs for adding a new item to an existing list via POST'
*****

This is exactly what we have functional tests for!



One More View to Handle Adding Items to an Existing List
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

We need a URL and view to handle adding a new item to an existing list (
'/lists/<list_id>/add_item').  We're getting pretty good at these now, so let's
knock one together quickly:

[role="sourcecode"]
.lists/tests.py
[source,python]
----
class NewItemTest(TestCase):

    def test_can_save_a_POST_request_to_an_existing_list(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        self.client.post(
            '/lists/%d/add_item' % (correct_list.id,),
            data={'item_text': 'A new item for an existing list'}
        )

        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, 'A new item for an existing list')
        self.assertEqual(new_item.list, correct_list)


    def test_redirects_to_list_view(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()

        response = self.client.post(
            '/lists/%d/add_item' % (correct_list.id,),
            data={'item_text': 'A new item for an existing list'}
        )

        self.assertRedirects(response, '/lists/%d/' % (correct_list.id,))
----

//IDEA: explain other_list

We get:

----
AssertionError: 0 != 1
[...]
AssertionError: 301 != 302 : Response didn't redirect as expected: Response
code was 301 (expected 302)
----


Beware of Greedy Regular Expressions!
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^


This was a bit of a puzzler, but it's because we've used a very "greedy"
regular expression in our URL:


[role="skipme"]
[source,python]
----
    url(r'^lists/(.+)/$', 'lists.views.view_list', name='view_list'),
----


[role="sourcecode"]
.superlists/urls.py
[source,python]
----
    url(r'^lists/(\d+)/$', 'lists.views.view_list', name='view_list'),
----

That gives:

----
AssertionError: 0 != 1
[...]
AssertionError: 404 != 302 : Response didn't redirect as expected: Response
code was 404 (expected 302)
----

The Last New URL
^^^^^^^^^^^^^^^^

Now we've got our expected 404, let's add a new URL for adding new items to
existing lists:

[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^lists/(\d+)/add_item$', 'lists.views.add_item', name='add_item'),
    url(r'^lists/new$', 'lists.views.new_list', name='new_list'),
    # url(r'^admin/', include(admin.site.urls)),
)
----

Three very similar-looking URLs there.  Let's make a note on our
to-do list; they look like good candidates for a refactoring.

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* '[strikethrough line-through]#Adjust model so that items are associated with different lists#'
* '[strikethrough line-through]#Add unique URLs for each list#'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* 'Add URLs for adding a new item to an existing list via POST'
* 'Refactor away some duplication in urls.py'
*****


Back to the tests, we now get:

----
django.core.exceptions.ViewDoesNotExist: Could not import lists.views.add_item.
View does not exist in module lists.views.
----


The Last New View
^^^^^^^^^^^^^^^^^

Let's try:


[role="sourcecode"]
.lists/views.py
[source,python]
----
def add_item(request):
    pass
----

Aha:

----
TypeError: add_item() takes 1 positional argument but 2 were given
----


[role="sourcecode"]
.lists/views.py
[source,python]
----
def add_item(request, list_id):
    pass
----

And then:

----
ValueError: The view lists.views.add_item didn't return an HttpResponse object.
It returned None instead.
----

++++
<?hard-pagebreak?>
++++

We can copy the `redirect` from `new_list` and the `List.objects.get` from
`view_list`:

[role="sourcecode"]
.lists/views.py
[source,python]
----
def add_item(request, list_id):
    list_ = List.objects.get(id=list_id)
    return redirect('/lists/%d/' % (list_.id,))
----

That takes us to:

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
----

Finally we make it save our new list item:


[role="sourcecode"]
.lists/views.py
[source,python]
----
def add_item(request, list_id):
    list_ = List.objects.get(id=list_id)
    Item.objects.create(text=request.POST['item_text'], list=list_)
    return redirect('/lists/%d/' % (list_.id,))
----

And we're back to passing tests.

----
Ran 9 tests in 0.050s

OK
----


But How to Use That URL in the Form?
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Now we just need to use this URL in our 'list.html' template.  Open it up and
adjust the form tag...

[role="sourcecode skipme"]
.lists/templates/list.html
[source,html]
----
    <form method="POST" action="but what should we put here?">
----


[role="sourcecode skipme"]
.lists/templates/list.html
[source,html]
----
    <form method="POST" action="/lists/{{ list.id }}/add_item">
----


For that to work, the view will have to pass the list to the template.
Let's create a new unit test in `ListViewTest`:

[role="sourcecode"]
.lists/tests.py (ch06l041)
[source,python]
----
    def test_passes_correct_list_to_template(self):
        other_list = List.objects.create()
        correct_list = List.objects.create()
        response = self.client.get('/lists/%d/' % (correct_list.id,))
        self.assertEqual(response.context['list'], correct_list)
----

//IDEA: explain correct_list, other_list


----
KeyError: 'list'
----

[role="sourcecode"]
.lists/views.py
[source,python]
----
def view_list(request, list_id):
    list_ = List.objects.get(id=list_id)
    return render(request, 'list.html', {'list': list_})
----

That, of course, will break because the template is expecting `items`:

----
AssertionError: False is not true : Couldn't find 'itemey 1' in response
----


[role="sourcecode"]
.lists/templates/list.html (ch06l043)
[source,html]
----
    <form method="POST" action="/lists/{{ list.id }}/add_item">

    [...]

        {% for item in list.item_set.all %}
            <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
        {% endfor %}
----

So that gets the unit tests to pass:

----
Ran 10 tests in 0.060s

OK
----

How about the FT?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test functional_tests*]
Creating test database for alias 'default'...
.
 ---------------------------------------------------------------------
Ran 1 test in 5.824s

OK
Destroying test database for alias 'default'...
----

Yes!  And a quick check on our to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Get FTs to clean up after themselves#'
* '[strikethrough line-through]#Adjust model so that items are associated with different lists#'
* '[strikethrough line-through]#Add unique URLs for each list#'
* '[strikethrough line-through]#Add a URL for creating a new list via POST#'
* '[strikethrough line-through]#Add URLs for adding a new item to an existing list via POST#'
* 'Refactor away some duplication in urls.py'
*****

((("Testing Goat")))
Irritatingly, the Testing Goat is a stickler for tying up loose ends too, so
we've got to do this one final thing.

((("test-driven development (TDD)", "Working state to working state")))
((("commits")))
Before we start, we'll do a commit--always make sure you've got a commit
of a working state before embarking on a refactor:

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am "new URL + view for adding to existing lists. FT passes :-)"*
----

A Final Refactor Using URL includes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[subs="specialcharacters,quotes"]
----
$ *cp superlists/urls.py lists/*
----

[role="sourcecode"]
.superlists/urls.py
[source,python]
----
urlpatterns = patterns('',
    url(r'^$', 'lists.views.home_page', name='home'),
    url(r'^lists/', include('lists.urls')),
    # url(r'^admin/', include(admin.site.urls)),
)
----

[role="sourcecode"]
.lists/urls.py (ch06l045)
[source,python]
----
from django.conf.urls import patterns, url

urlpatterns = patterns('',
    url(r'^(\d+)/$', 'lists.views.view_list', name='view_list'),
    url(r'^(\d+)/add_item$', 'lists.views.add_item', name='add_item'),
    url(r'^new$', 'lists.views.new_list', name='new_list'),
)
----

[subs="specialcharacters,quotes"]
----
$ *git status*
$ *git add lists/urls.py*
$ *git add superlists/urls.py*
$ *git diff --staged*
$ *git commit*
----


.Useful TDD Concepts and Rules Of Thumb
*******************************************************************************

Test Isolation and Global State::
    Different tests shouldn't affect one another.  This means we need to
    reset any permanent state at the end of each test. Django's test runner
    helps us do this by creating a test database, which it wipes clean in
    between each test.  (See also <<isolation-chapter>>.)
    ((("test isolation")))
    ((("functional tests/testing (FT)", "isolation in")))

Working State to Working State (aka The Testing Goat vs. Refactoring Cat)::
    Our natural urge is often to dive in and fix everything at once ... but if
    we're not careful, we'll end up like Refactoring Cat, in a situation with
    loads of changes to our code and nothing working.  The Testing Goat
    encourages us to take one step at a time, and go from working state to
    working state.
    ((("test-driven development (TDD)", "Working state to working state")))
    ((("Testing Goat")))
    ((("Refactoring Cat")))

YAGNI::
    You ain't gonna need it!  Avoid the temptation to write code that you 
    think 'might' be useful, just because it suggests itself at the time.
    Chances are, you won't use it, or you won't have anticipated your
    future requirements correctly.  See <<outside-in-chapter>> for one
    methodology that helps us avoid this trap.

*******************************************************************************

