[[chapter-4]]
What Are We Doing with All These Tests?
---------------------------------------

[[figure4-1]]
.Test ALL the things (original illustration source: http://bit.ly/1iXxdYp[Allie Brosh, Hyperbole and a Half])
image::images/twdp_0401.png[Test ALL the things,float="right"]

Topics to discuss:

* "Bucket from a well" metaphor
* TDD as a discipline -- kata
* the value of ridiculously small/simple tests?

Now, back to our onions.


Using Selenium to Test User Interactions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Where were we at the end of the last chapter? Let's rerun the test and find
out:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 functional_tests.py*]
F
======================================================================
FAIL: test_can_start_a_list_and_retrieve_it_later (__main__.NewVisitorTest)
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "functional_tests.py", line 20, in
test_can_start_a_list_and_retrieve_it_later
    self.fail('Finish the test!')
AssertionError: Finish the test!

 ---------------------------------------------------------------------
Ran 1 test in 1.609s

FAILED (failures=1)
----


Did you try it, and get an error saying 'Problem loading page' or
'Unable to connect'?  So did I. It's because we forgot to spin up the dev
server first using `manage.py runserver`.  Do that, and you'll get the failure
message we're after.

``Finish the test'', it says, so let's do just that!  Open up
'functional_tests.py' and we'll extend our FT:


[role="sourcecode"]
.functional_tests.py
[source,python]
----
from selenium import webdriver
from selenium.webdriver.common.keys import Keys
import unittest

class NewVisitorTest(unittest.TestCase):

    def setUp(self):
        self.browser = webdriver.Firefox()
        self.browser.implicitly_wait(3)

    def tearDown(self):
        self.browser.quit()

    def test_can_start_a_list_and_retrieve_it_later(self):
        # Edith has heard about a cool new online to-do app. She goes
        # to check out its homepage
        self.browser.get('http://localhost:8000')

        # She notices the page title and header mention to-do lists
        self.assertIn('To-Do', self.browser.title)
        header_text = self.browser.find_element_by_tag_name('h1').text
        self.assertIn('To-Do', header_text)

        # She is invited to enter a to-do item straight away
        inputbox = self.browser.find_element_by_id('id_new_item')
        self.assertEqual(
                inputbox.get_attribute('placeholder'),
                'Enter a to-do item'
        )

        # She types "Buy peacock feathers" into a text box (Edith's hobby
        # is tying fly-fishing lures)
        inputbox.send_keys('Buy peacock feathers')

        # When she hits enter, the page updates, and now the page lists
        # "1: Buy peacock feathers" as an item in a to-do list table
        inputbox.send_keys(Keys.ENTER)

        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')
        self.assertTrue(
            any(row.text == '1: Buy peacock feathers' for row in rows)
        )

        # There is still a text box inviting her to add another item. She
        # enters "Use peacock feathers to make a fly" (Edith is very
        # methodical)
        self.fail('Finish the test!')

        # The page updates again, and now shows both items on her list
        [...]
----

Ask about:
* `find_element_by_tag_name`, `find_element_by_id`, 
* `find_element`**`s`**`_by_tag_name` (notice the extra `s`)
* `send_keys`,
* `Keys` class 
* `any` function + generator expressions

TIP: Watch out for the difference between the Selenium `find_element_by...`
and `find_elements_by...` functions.  One returns an element, and raises
an exception if it can't find it, whereas the other returns a list, which
may be empty.

Let's see how it gets on:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 functional_tests.py*]
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"tag name","selector":"h1"}
Stacktrace:
[...]
----

Big changes to a functional test are usually a good thing to commit on their
own 

[subs="specialcharacters,quotes"]
----
$ *git diff*  # should show changes to functional_tests.py
$ *git commit -am "Functional test now checks we can input a to-do item"*
----




The ``Don't Test Constants'' Rule, and Templates to the Rescue
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In other words, if you have some code that says:


[source,python]
----
wibble = 3
----

There's not much point in a test that says:

[source,python]
----
from myprogram import wibble
assert wibble == 3
----


Refactoring to Use a Template
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Objective: **refactor** view to return same HTML

Start with test run:


[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test*
[...]
OK
----


[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
<html>
    <title>To-Do lists</title>
</html>
----


Mmmh, syntax-highlighted ... much nicer! Now to change our view function:


[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.shortcuts import render

def home_page(request):
    return render(request, 'home.html')
----


Let's see if it works:

[subs="specialcharacters,macros,callouts"]
----
$ pass:quotes[*python3 manage.py test*]
[...]
======================================================================
ERROR: test_home_page_returns_correct_html (lists.tests.HomePageTest)<2>
 ---------------------------------------------------------------------
Traceback (most recent call last):
  File "/workspace/superlists/lists/tests.py", line 17, in
test_home_page_returns_correct_html
    response = home_page(request)<3>
  File "/workspace/superlists/lists/views.py", line 5, in home_page
    return render(request, 'home.html')<4>
  File "/usr/local/lib/python3.3/dist-packages/django/shortcuts.py", line 48,
in render
    return HttpResponse(loader.render_to_string(*args, **kwargs),
  File "/usr/local/lib/python3.3/dist-packages/django/template/loader.py", line
170, in render_to_string
    t = get_template(template_name, dirs)
  File "/usr/local/lib/python3.3/dist-packages/django/template/loader.py", line
144, in get_template
    template, origin = find_template(template_name, dirs)
  File "/usr/local/lib/python3.3/dist-packages/django/template/loader.py", line
136, in find_template
    raise TemplateDoesNotExist(name)
django.template.base.TemplateDoesNotExist: home.html<1>

 ---------------------------------------------------------------------
Ran 2 tests in 0.004s
----

Another chance to analyse a traceback:

<1> We start with the error: it can't find the template.

<2> Then we double-check what test is failing: sure enough, it's our test
    of the view HTML.

<3> Then we find the line in our tests that caused the failure: it's when
    we call the `home_page` function.

<4> Finally, we look for the part of our own application code that caused the
    failure: it's when we try and call `render`.


So why can't Django find the template?  It's right where it's supposed to be,
in the 'lists/templates' folder.


* Need to add lists app to 'settings.py':


[role="sourcecode"]
.superlists/settings.py
[source,python]
----
# Application definition

INSTALLED_APPS = (
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'lists',
)
----


Does that do the trick?


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test*]
    [...]
    self.assertTrue(response.content.endswith(b'</html>'))
AssertionError: False is not true
----

Darn, not quite.

NOTE: Depending on whether your text editor insists on adding newlines to the
      end of files, you may not even see this error.  If so, you can safely
      ignore the next bit, and skip straight to where you can see the listing
      says OK.


[role="sourcecode"]
.lists/tests.py
[source,python]
----
self.assertTrue(response.content.strip().endswith(b'</html>'))
----

hooray!

[subs="specialcharacters,quotes"]
----
$ *python3 manage.py test*
[...]
OK
----

Now we can change the tests so that they're no longer testing constants

[role="sourcecode"]
.lists/tests.py
[source,python]
----
from django.template.loader import render_to_string
[...]

    def test_home_page_returns_correct_html(self):
        request = HttpRequest()
        response = home_page(request)
        expected_html = render_to_string('home.html')
        self.assertEqual(response.content.decode(), expected_html)
----

* ask about .decode() if we haven't spoken about Python 3 and strings vs bytes


.Advanced Exercise:
********************************************************************

Look up the Django Test Client.  How would you use it to check that our view
is using the correct template?

********************************************************************


On refactoring
~~~~~~~~~~~~~~

[quote, Kent Beck, TDD by example]
____________________________________________________________________________
Am I recommending that you actually work this way? No. I'm recommending that
you be 'able' to work this way.
____________________________________________________________________________

TIP: When refactoring, work on either the code or the tests, but not both at
     once.

[[RefactoringCat]]
.Refactoring Cat--be sure to look up the full animated GIF (source: 4GIFs.com)
image::images/twdp_0402.png[An adventurous cat, trying to refactor its way out of a slippery bathtub]



It's a good idea to do a commit after any refactoring:

[subs="specialcharacters,quotes"]
----
$ *git status* # see tests.py, views.py, settings.py, + new templates folder
$ *git add .*  # will also add the untracked templates folder
$ *git diff --staged* # review the changes we're about to commit
$ *git commit -m "Refactor home page view to use a template"*
----



A Little More of Our Front Page
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the meantime, our functional test is still failing.  Let's now make an
actual code change to get it passing.  

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
<html>
    <head>
        <title>To-Do lists</title>
    </head>
    <body>
        <h1>Your To-Do list</h1>
    </body>
</html>
----

Let's see if our functional test likes it a little better:

----
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"id","selector":"id_new_item"}
----

OK...


[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
    [...]
        <h1>Your To-Do list</h1>
        <input id="id_new_item" />
    </body>
    [...]
----

And now?

----
AssertionError: '' != 'Enter a to-do item'
----

We add our placeholder text...

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
    <input id="id_new_item" placeholder="Enter a to-do item" />
----

Which gives:

----
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"id","selector":"id_list_table"}
----

So we can go ahead and put the table onto the page. At this stage it'll just be
empty...

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
    <input id="id_new_item" placeholder="Enter a to-do item" />
    <table id="id_list_table">
    </table>
</body>
----

Now what does the FT say?

----
  File "functional_tests.py", line 42, in
test_can_start_a_list_and_retrieve_it_later
    any(row.text == '1: Buy peacock feathers' for row in rows)
AssertionError: False is not true
----

That `any` function!


[role="sourcecode"]
.functional_tests.py
[source,python]
----
    self.assertTrue(
        any(row.text == '1: Buy peacock feathers' for row in rows),
        "New to-do item did not appear in table"
    )
----

If you run the FT again, you should see our message:

----
AssertionError: False is not true : New to-do item did not appear in table
----

But now, to get this to pass, we will need to actually process the user's
form submission.  And that's a topic for the next chapter.

For now let's do a commit:

[subs="specialcharacters,quotes"]
----
$ *git diff*
$ *git commit -am "Front page HTML now generated from a template"*
----


Thanks to a bit of refactoring, we've got our view set up to render a template,
we've stopped testing constants, and we're now well placed to start processing
user input.

.Advanced Exercise:
********************************************************************

How could we improve that check-that-the-new-item-has-appeared-in-the-table
assertion further?   

********************************************************************


Recap: The TDD Process
~~~~~~~~~~~~~~~~~~~~~~

We've now seen all the main aspects of the TDD process, in practice:

* Functional tests
* Unit tests
* The unit-test/code cycle
* Refactoring

What is the overall TDD process? See <<simple-TDD-diagram>>.



[[simple-TDD-diagram]]
.Overall TDD process
image::images/twdp_0403.png[A flowchart showing tests, coding and refactoring]


[[Double-Loop-TDD-diagram]]
.The TDD process with functional and unit tests
image::images/twdp_0404.png[A flowchart showing functional tests as the overall cycle, and unit tests helping to code]



.How to "Check" Your Code, or Skip Ahead (If You Must)
*******************************************************************************

All of the code examples I've used in the book are available in
https://github.com/hjwp/book-example/[my repo] on GitHub.  So, if you ever want
to compare your code against mine, you can take a look at it there.

Each chapter has its own branch following the convention `chapter_XX`:

* Chapter 3: https://github.com/hjwp/book-example/tree/chapter_03

* Chapter 4: https://github.com/hjwp/book-example/tree/chapter_04

* Chapter 5: https://github.com/hjwp/book-example/tree/chapter_05

* Etc.

Be aware that each branch contains all of the commits for that chapter,
so its state represents the code at the 'end' of the chapter.


**Using Git to check your progress**

If you feel like developing your Git-Fu a little further, you can add
my repo as a 'remote':

[role="skipme"]
-----
git remote add harry https://github.com/hjwp/book-example.git
git fetch harry
-----

And then, to check your difference from the 'end' of <<chapter-4>>:

[role="skipme"]
----
git diff harry/chapter_04
----

Git can handle multiple remotes, so you can still do this even if you're
already pushing your code up to GitHub or Bitbucket.

Be aware that the precise order of, say, methods in a class may differ
between your version and mine.  It may make diffs hard to read.


**Downloading a ZIP file for a chapter**

https://github.com/hjwp/book-example/archive/chapter_05.zip

https://github.com/hjwp/book-example/archive/chapter_06.zip

*******************************************************************************

