[[chapter-5]]
Saving User Input
-----------------


Wiring Up Our Form to Send a POST Request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

To get our browser to send a POST request, we give the `<input>` element a
`name=` attribute, wrap it in a `<form>` tag with `method="POST"`, and the
browser will take care of sending the POST request to the server for us. Let's
adjust our template at 'lists/templates/home.html':

[role="sourcecode dofirst-ch05l000"]
.lists/templates/home.html
[source,html]
----
<h1>Your To-Do list</h1>
<form method="POST">
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
</form>

<table id="id_list_table">
----

Now, running our FTs gives us a slightly cryptic, unexpected error:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 functional_tests.py*]
[...]
Traceback (most recent call last):
  File "functional_tests.py", line 39, in
test_can_start_a_list_and_retrieve_it_later
    table = self.browser.find_element_by_id('id_list_table')
[...]
selenium.common.exceptions.NoSuchElementException: Message: Unable to locate
element: {"method":"id","selector":"id_list_table"}
----

((("debugging")))
When a functional test fails with an unexpected failure, there are several
things we can do to debug them:

* Add `print` statements, to show, eg, what the current page text is.
* Improve the 'error message' to show more info about the current state.
* Manually visit the site yourself.
* Use `time.sleep` to pause the test during execution.

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)

    import time
    time.sleep(10)
    table = self.browser.find_element_by_id('id_list_table')
----

[[csrf_error_screenshot]]
.Django DEBUG page showing CSRF error
image::images/twdp_0501.png[Django DEBUG page showing CSRF error]


NOTE: check out Ross Anderson's "Security Engineering"


csrf token magic:

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
<form method="POST">
    <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
    {% csrf_token %}
</form>
----

----
AssertionError: False is not true : New to-do item did not appear in table
----

We can remove the `time.sleep` now though:

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)

    table = self.browser.find_element_by_id('id_list_table')
----


Processing a POST Request on the Server
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[role="sourcecode"]
.lists/tests.py (ch05l005)
[source,python]
----
def test_home_page_returns_correct_html(self):
    [...]


def test_home_page_can_save_a_POST_request(self):
    request = HttpRequest()
    request.method = 'POST'
    request.POST['item_text'] = 'A new list item'

    response = home_page(request)

    self.assertIn('A new list item', response.content.decode())
----

* Ask about: line spacing in tests


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test*]
[...]
AssertionError: 'A new list item' not found in '<html> [...]
----

In typical TDD style, we start with a deliberately silly return value:

[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.http import HttpResponse
from django.shortcuts import render

def home_page(request):
    if request.method == 'POST':
        return HttpResponse(request.POST['item_text'])
    return render(request, 'home.html')
----


That gets our unit tests passing, but it's not really what we want.  What we 
really want to do is add the POST submission to the table in the home page
template.


Passing Python Variables to Be Rendered in the Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[role="sourcecode small-code"]
.lists/templates/home.html
[source,html]
----
<body>
    <h1>Your To-Do list</h1>
    <form method="POST">
        <input name="item_text" id="id_new_item" placeholder="Enter a to-do item" />
        {% csrf_token %}
    </form>

    <table id="id_list_table">
        <tr><td>{{ new_item_text }}</td></tr>
    </table>
</body>
----

Use template variable in test:


[role="sourcecode"]
.lists/tests.py
[source,python]
----
    self.assertIn('A new list item', response.content.decode())
    expected_html = render_to_string(
        'home.html',
        {'new_item_text':  'A new list item'}
    )
    self.assertEqual(response.content.decode(), expected_html)
----

Next:

----
    self.assertEqual(response.content.decode(), expected_html)
AssertionError: 'A new list item' != '<html>\n    <head>\n [...]
----

use in view:

[role="sourcecode"]
.lists/views.py (ch05l009)
[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST['item_text'],
    })
----

Running the unit tests again:

----
ERROR: test_home_page_returns_correct_html (lists.tests.HomePageTest)
[...]
    'new_item_text': request.POST['item_text'],
KeyError: 'item_text'
----


An "unexpected failure"...  in a different test!  'This is the whole point of
having tests'.


[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----

* confused about request.POST.get?  ask!

The unit tests should now pass.  Let's see what the functional tests say:

----
AssertionError: False is not true : New to-do item did not appear in table
----


Hmm, not a wonderfully helpful error.  Let's use another of our FT debugging
techniques: improving the error message.  This is probably the most
constructive technique, because those improved error messages stay around to
help debug any future errors:

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    self.assertTrue(
        any(row.text == '1: Buy peacock feathers' for row in rows),
        "New to-do item did not appear in table -- its text was:\n%s" % (
            table.text,
        )
    )
----

That gives us a more helpful error message:

----
AssertionError: False is not true : New to-do item did not appear in table --
its text was:
Buy peacock feathers
----

You know what could be even better than that?  


[role="sourcecode"]
.functional_tests.py
[source,python]
----
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
----

* Discussion point: feeling clever about your code is a code smell!

Much better.  

----
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
AssertionError: '1: Buy peacock feathers' not found in ['Buy peacock feathers']
----



TIP: If, instead, your FT seems to be saying the table is empty ("not found in
[]"), check your `<input>` tag -- does it have the correct `name="item_text"`
attribute?  Without it, the user's input won't be associated with the right
key in `request.POST`.

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
    <tr><td>1: {{ new_item_text }}</td></tr>
----

NOTE: ask about Red/Green/Refactor, and Triangulation


Now we get to the `self.fail('Finish the test!')`.  If we extend our FT to 
check for adding a second item to the table (copy and paste is our friend), we
begin to see that our first cut solution really isn't going to, um, cut it:

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    # There is still a text box inviting her to add another item. She
    # enters "Use peacock feathers to make a fly" (Edith is very
    # methodical)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Use peacock feathers to make a fly')
    inputbox.send_keys(Keys.ENTER)

    # The page updates again, and now shows both items on her list
    table = self.browser.find_element_by_id('id_list_table')
    rows = table.find_elements_by_tag_name('tr')
    self.assertIn('1: Buy peacock feathers', [row.text for row in rows])
    self.assertIn(
        '2: Use peacock feathers to make a fly' ,
         [row.text for row in rows]
    )

    # Edith wonders whether the site will remember her list. Then she sees
    # that the site has generated a unique URL for her -- there is some
    # explanatory text to that effect.
    self.fail('Finish the test!')

    # She visits that URL - her to-do list is still there.
----

Sure enough, the functional tests return an error:

----
AssertionError: '1: Buy peacock feathers' not found in ['1: Use peacock
feathers to make a fly']
----

Three Strikes and Refactor
~~~~~~~~~~~~~~~~~~~~~~~~~~

Before we go further--we've got a bad ``code smell'' in this FT. 


[subs="specialcharacters,quotes"]
----
$ *git diff*
# should show changes to functional_tests.py, home.html,
# tests.py and views.py
$ *git commit -a*
----

Helper:


[role="sourcecode"]
.functional_tests.py
[source,python]
----
    def tearDown(self):
        self.browser.quit()


    def check_for_row_in_list_table(self, row_text):
        table = self.browser.find_element_by_id('id_list_table')
        rows = table.find_elements_by_tag_name('tr')
        self.assertIn(row_text, [row.text for row in rows])


    def test_can_start_a_list_and_retrieve_it_later(self):
        [...]
----

Let's use it in the FT:

[role="sourcecode"]
.functional_tests.py
[source,python]
----
    # When she hits enter, the page updates, and now the page lists
    # "1: Buy peacock feathers" as an item in a to-do list table
    inputbox.send_keys(Keys.ENTER)
    self.check_for_row_in_list_table('1: Buy peacock feathers')

    # There is still a text box inviting her to add another item. She
    # enters "Use peacock feathers to make a fly" (Edith is very
    # methodical)
    inputbox = self.browser.find_element_by_id('id_new_item')
    inputbox.send_keys('Use peacock feathers to make a fly')
    inputbox.send_keys(Keys.ENTER)

    # The page updates again, and now shows both items on her list
    self.check_for_row_in_list_table('1: Buy peacock feathers')
    self.check_for_row_in_list_table('2: Use peacock feathers to make a fly')

    # Edith wonders whether the site will remember her list. Then she sees
    [...]
----

We run the FT again to check that it still behaves in the same way...

----
AssertionError: '1: Buy peacock feathers' not found in ['1: Use peacock
feathers to make a fly']
----

Good. Now we can commit the FT refactor as its own small, atomic change:


[subs="specialcharacters,quotes"]
----
$ *git diff* # check the changes to functional_tests.py
$ *git commit -a*
----

And back to work.  



The Django ORM and Our First Model
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Let's create a new class in 'lists/tests.py':

[role="sourcecode"]
.lists/tests.py
[source,python]
----
from lists.models import Item
[...]

class ItemModelTest(TestCase):

    def test_saving_and_retrieving_items(self):
        first_item = Item()
        first_item.text = 'The first (ever) list item'
        first_item.save()

        second_item = Item()
        second_item.text = 'Item the second'
        second_item.save()

        saved_items = Item.objects.all()
        self.assertEqual(saved_items.count(), 2)

        first_saved_item = saved_items[0]
        second_saved_item = saved_items[1]
        self.assertEqual(first_saved_item.text, 'The first (ever) list item')
        self.assertEqual(second_saved_item.text, 'Item the second')
----


Django's ORM has many other helpful and intuitive features; this might be a
good time to skim through the
https://docs.djangoproject.com/en/1.7/intro/tutorial01/[Django
tutorial], which has an excellent intro to them.
((("unit tests", "vs. integrated tests", sortas="integratedtests")))
((("integrated tests", "vs. unit tests", sortas="unittests")))


NOTE: I've written this unit test in a very verbose style, as a way of
introducing the Django ORM.  You can actually write a much shorter test for a
model class, which we'll see later on, in <<simple-form-chapter>>.

.Advanced Exercise:
********************************************************************

What's the simplest version of this test that still thoroughly tests the
class?

********************************************************************

NOTE: Ask about integrated vs pure unit tests, and "the database is Hot Lava!"


[subs="specialcharacters,macros"]
----
ImportError: cannot import name 'Item'
----


[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.db import models

class Item(object):
    pass
----

That gets our test as far as: 

----
    first_item.save()
AttributeError: 'Item' object has no attribute 'save'
----

To give our `Item` class a `save` method, and to make it into a real Django
model, we make it inherit from the `Model` class:


[role="sourcecode"]
.lists/models.py
[source,python]
----
from django.db import models

class Item(models.Model):
    pass
----


Our First Database Migration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The next thing that happens is a database error:

----
django.db.utils.OperationalError: no such table: lists_item
----

NOTE: Ask about "migrations are a VCS for your database"

For now all we need to know is how to build our first database migration,
which we do using the `makemigrations` command:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py makemigrations*]
Migrations for 'lists':
  0001_initial.py:
    - Create model Item
$ pass:quotes[*ls lists/migrations*]
0001_initial.py  __init__.py  __pycache__
----

If you're curious, you can go and take a look in the migrations file,
and you'll see it's a representation of our additions to 'models.py'.

In the meantime, we should find our tests get a little further.


The Test Gets Surprisingly Far
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The test actually gets surprisingly far:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]
    self.assertEqual(first_saved_item.text, 'The first (ever) list item')
AttributeError: 'Item' object has no attribute 'text'
----

* Discussion:  how did it get this far?


Next:

[role="sourcecode"]
.lists/models.py
[source,python]
----
class Item(models.Model):
    text = models.TextField()
----

You can read more on field types in the Django
http://bit.ly/1slDAGH[tutorial]
and in the
https://docs.djangoproject.com/en/1.7/ref/models/fields/[documentation].



A New Field Means a New Migration
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Running the tests gives us another database error:

----
django.db.utils.OperationalError: no such column: lists_item.text
----

It's because we've added another new field to our database, which means we need
to create another migration.  Nice of our tests to let us know!

Let's try it:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py makemigrations*]
You are trying to add a non-nullable field 'text' to item without a default; we
can't do that (the database needs something to populate existing rows).
Please select a fix:
 1) Provide a one-off default now (will be set on all existing rows)
 2) Quit, and let me add a default in models.py
Select an option:pass:quotes[*2*]
----

Ah.  It won't let us add the column without a default value.  Let's pick option
2 and set a default in 'models.py'.  I think you'll find the syntax reasonably
self-explanatory:


[role="sourcecode"]
.lists/models.py
[source,python]
----
class Item(models.Model):
    text = models.TextField(default='')
----

//IDEA: default could get another unit test, which could actually replace the
// overly verbose one.

And now the migration should complete:

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py makemigrations*]
Migrations for 'lists':
  0002_item_text.py:
    - Add field text to item
----

So, two new lines in 'models.py', two database migrations, and as a result,
the `.text` attribute on our model objects is now 
recognised as a special attribute, so it does get saved to the database, and
the tests pass...

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py test lists*]
[...]

Ran 4 tests in 0.010s
OK
----


So let's do a commit for our first ever model!


[subs="specialcharacters,quotes"]
----
$ *git status* # see tests.py, models.py, and 2 untracked migrations
$ *git diff* # review changes to tests.py and models.py
$ *git add lists*
$ *git commit -m "Model for list Items and associated migration"*
----


Saving the POST to the Database
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

[role="sourcecode"]
.lists/tests.py
[source,python]
----
def test_home_page_can_save_a_POST_request(self):
    request = HttpRequest()
    request.method = 'POST'
    request.POST['item_text'] = 'A new list item'

    response = home_page(request)

    self.assertEqual(Item.objects.count(), 1)  #<1>
    new_item = Item.objects.first()  #<2>
    self.assertEqual(new_item.text, 'A new list item')  #<3>

    self.assertIn('A new list item', response.content.decode())
    expected_html = render_to_string(
        'home.html',
        {'new_item_text':  'A new list item'}
    )
    self.assertEqual(response.content.decode(), expected_html)
----


A reminder on a scratch piece of paper:

[role="scratchpad"]
*****
* 'Code smell: POST test is too long?'
*****

----
    self.assertEqual(Item.objects.count(), 1)
AssertionError: 0 != 1
----

Let's adjust our view:

[role="sourcecode"]
.lists/views.py
[source,python]
----
from django.shortcuts import render
from lists.models import Item

def home_page(request):
    item = Item()
    item.text = request.POST.get('item_text', '')
    item.save()

    return render(request, 'home.html', {
        'new_item_text': request.POST.get('item_text', ''),
    })
----


[role="sourcecode"]
.lists/views.py
[source,python]
----
    return render(request, 'home.html', {
        'new_item_text': item.text
    })
----

Let's have a little look at our scratchpad. I've added a couple of the other
things that are on our mind:

[role="scratchpad"]
*****
* 'Don't save blank items for every request'
* 'Code smell: POST test is too long?'
* 'Display multiple items in the table'
* 'Support more than one list!'
*****


[role="sourcecode"]
.lists/tests.py
[source,python]
----
class HomePageTest(TestCase):
    [...]

    def test_home_page_only_saves_items_when_necessary(self):
        request = HttpRequest()
        home_page(request)
        self.assertEqual(Item.objects.count(), 0)
----

That gives us a `1 != 0` failure.  


[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        new_item_text = request.POST['item_text']  #<1>
        Item.objects.create(text=new_item_text)  #<2>
    else:
        new_item_text = ''  #<1>

    return render(request, 'home.html', {
        'new_item_text': new_item_text,  #<1>
    })
----


----
Ran 5 tests in 0.010s

OK
----


Redirect After a POST
~~~~~~~~~~~~~~~~~~~~~


[role="sourcecode"]
.lists/tests.py
[source,python]
----
    def test_home_page_can_save_a_POST_request(self):
        request = HttpRequest()
        request.method = 'POST'
        request.POST['item_text'] = 'A new list item'

        response = home_page(request)

        self.assertEqual(Item.objects.count(), 1)
        new_item = Item.objects.first()
        self.assertEqual(new_item.text, 'A new list item')

        self.assertEqual(response.status_code, 302)
        self.assertEqual(response['location'], '/')
----

That gives us the error `200 != 302`.  We can now tidy up our view
substantially:

[role="sourcecode"]
.lists/views.py (ch05l028)
[source,python]
----
from django.shortcuts import redirect, render
from lists.models import Item

def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    return render(request, 'home.html')
----


And the tests should now pass:

----
Ran 5 tests in 0.010s

OK
----


.Advanced exercise: each test should test one thing
********************************************************************

[role="sourcecode skipme"]
.lists/tests.py
[source,python]
----
    def test_home_page_can_save_a_POST_request(self):
        ?


    def test_home_page_redirects_after_POST(self):
        ?
----


And we should now see six tests pass instead of five:

[role="skipme"]
----
Ran 6 tests in 0.010s

OK
----

********************************************************************

Rendering Items in the Template
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Back to our to-do list:

[role="scratchpad"]
*****
* '[strikethrough line-through]#Don't save blank items for every request#'
* '[strikethrough line-through]#Code smell: POST test is too long?#'
* 'Display multiple items in the table'
* 'Support more than one list!'
*****


[role="sourcecode"]
.lists/tests.py
[source,python]
----
class HomePageTest(TestCase):
    [...]

    def test_home_page_displays_all_list_items(self):
        Item.objects.create(text='itemey 1')
        Item.objects.create(text='itemey 2')

        request = HttpRequest()
        response = home_page(request)

        self.assertIn('itemey 1', response.content.decode())
        self.assertIn('itemey 2', response.content.decode())
----

That fails as expected:

----
AssertionError: 'itemey 1' not found in '<html>\n    <head>\n [...]
----

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
<table id="id_list_table">
    {% for item in items %}
        <tr><td>1: {{ item.text }}</td></tr>
    {% endfor %}
</table>
----

Just changing the template doesn't get our tests to pass; we need to actually
pass the items to it from our home page view:

++++
<?hard-pagebreak?>
++++

[role="sourcecode"]
.lists/views.py
[source,python]
----
def home_page(request):
    if request.method == 'POST':
        Item.objects.create(text=request.POST['item_text'])
        return redirect('/')

    items = Item.objects.all()
    return render(request, 'home.html', {'items': items})
----


.Advanced Exercise:
********************************************************************

If you didn't find out about it in the last chapter, find out about the
Django Test Client.  How would you re-write our test(s) for the home page view
now?

********************************************************************


That does get the unit tests to pass ... moment of truth, will the functional
test pass?

[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 functional_tests.py*]
[...]
AssertionError: 'To-Do' not found in 'OperationalError at /'
----


Oops, apparently not.  Let's use another functional test debugging technique,
and it's one of the most straightforward: manually visiting the site!  Open
up 'http://localhost:8000' in your web browser, and you'll see a Django debug
page saying "no such table: lists_item", as in <<operationalerror>>.


[[operationalerror]]
.Another helpful debug message
image::images/twdp_0502.png[OperationalError at / no such table: lists_item]



Creating Our Production Database with migrate
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


[role="sourcecode currentcontents"]
.superlists/settings.py
[source,python]
----
[...]
# Database
# https://docs.djangoproject.com/en/1.7/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
----


[subs="specialcharacters,macros"]
----
$ pass:quotes[*python3 manage.py migrate*]
Operations to perform:
  Apply all migrations: contenttypes, lists, admin, auth, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying lists.0001_initial... OK
  Applying lists.0002_item_text... OK
  Applying sessions.0001_initial... OK
----

Now we can refresh the page on 'localhost', see that our error is gone, and try
running the functional tests
again:footnote:[If you get a different error at this point, try restarting your
dev server--it may have gotten confused by the changes to the database
happening under its feet.]

----
AssertionError: '2: Use peacock feathers to make a fly' not found in ['1: Buy
peacock feathers', '1: Use peacock feathers to make a fly']
----


So close!  We just need to get our list numbering right.  Another awesome
Django template tag, `forloop.counter`, will help here:

[role="sourcecode"]
.lists/templates/home.html
[source,html]
----
    {% for item in items %}
        <tr><td>{{ forloop.counter }}: {{ item.text }}</td></tr>
    {% endfor %}
----


If you try it again, you should now see the FT get to the end:

----
    self.fail('Finish the test!')
AssertionError: Finish the test!
----


Oh dear. It looks like previous runs of the test are leaving stuff lying around
in our database.  

----
1: Buy peacock feathers
2: Use peacock feathers to make a fly
3: Buy peacock feathers
4: Use peacock feathers to make a fly
5: Buy peacock feathers
6: Use peacock feathers to make a fly
----

Grrr.  We're so close! 


[subs="specialcharacters,quotes"]
----
$ *rm db.sqlite3*
$ *python3 manage.py migrate --noinput*
----

That's more or less working.  Commit for now.


[subs="specialcharacters,quotes"]
----
$ *git add lists*
$ *git commit -m "Redirect after POST, and show all items in template"*
----

TIP: You might find it useful to add markers for the end of each chapter, like
*`git tag end-of-chapter-05`*.


Where are we?  

* We've got a form set up to add new items to the list using POST.

* We've set up a simple model in the database to save list items.

* We've used at least three different FT debugging techniques.

But we've got a couple of items on our own to-do list, namely getting the FT to
clean up after itself, and perhaps more critically, adding support for more
than one list.  

I mean, we 'could' ship the site as it is, but people might find it
strange that the entire human population has to share a single to-do list.  I
suppose it might get people to stop and think about how connected we all are to
one another, how we all share a common destiny here on Spaceship Earth, and how
we must all work together to solve the global problems that we face.  

But in practical terms, the site wouldn't be very useful.

Ah well.

.Useful TDD Concepts
*******************************************************************************

Regression::
    When new code breaks some aspect of the application which used to work.

Unexpected failure::
    When a test fails in a way we weren't expecting.  This either means that
    we've made a mistake in our tests, or that the tests have helped us find
    a regression, and we need to fix something in our code.

Red/Green/Refactor::
    Another way of describing the TDD process. Write a test and see it fail
    (Red), write some code to get it to pass (Green), then Refactor to improve
    the implementation.

Triangulation::
    Adding a test case with a new specific example for some existing code, to
    justify generalising the implementation (which may be a "cheat" until that
    point).

Three strikes and refactor::
    A rule of thumb for when to remove duplication from code. When two pieces
    of code look very similar, it often pays to wait until you see a third
    use case, so that you're more sure about what part of the code really
    is the common, re-usable part to refactor out.

The scratchpad to-do list::
    A place to write down things that occur to us as we're coding, so that
    we can finish up what we're doing and come back to them later.

*******************************************************************************

